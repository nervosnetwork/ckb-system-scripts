// Generated by Molecule 0.4.1

#include "molecule_reader.h"
#include "molecule_builder.h"

#ifndef BLOCKCHAIN_H
#define BLOCKCHAIN_H

#ifdef __cplusplus
#define _CPP_BEGIN extern "C" {
#define _CPP_END }
_CPP_BEGIN
#endif /* __cplusplus */

/*
 * Reader APIs
 */

#define         MolReader_Uint32_verify(s, c)                   mol_verify_fixed_size(s, 4)
#define         MolReader_Uint32_get_nth0(s)                    mol_slice_by_offset(s, 0, 1)
#define         MolReader_Uint32_get_nth1(s)                    mol_slice_by_offset(s, 1, 1)
#define         MolReader_Uint32_get_nth2(s)                    mol_slice_by_offset(s, 2, 1)
#define         MolReader_Uint32_get_nth3(s)                    mol_slice_by_offset(s, 3, 1)
#define         MolReader_Uint64_verify(s, c)                   mol_verify_fixed_size(s, 8)
#define         MolReader_Uint64_get_nth0(s)                    mol_slice_by_offset(s, 0, 1)
#define         MolReader_Uint64_get_nth1(s)                    mol_slice_by_offset(s, 1, 1)
#define         MolReader_Uint64_get_nth2(s)                    mol_slice_by_offset(s, 2, 1)
#define         MolReader_Uint64_get_nth3(s)                    mol_slice_by_offset(s, 3, 1)
#define         MolReader_Uint64_get_nth4(s)                    mol_slice_by_offset(s, 4, 1)
#define         MolReader_Uint64_get_nth5(s)                    mol_slice_by_offset(s, 5, 1)
#define         MolReader_Uint64_get_nth6(s)                    mol_slice_by_offset(s, 6, 1)
#define         MolReader_Uint64_get_nth7(s)                    mol_slice_by_offset(s, 7, 1)
#define         MolReader_Uint128_verify(s, c)                  mol_verify_fixed_size(s, 16)
#define         MolReader_Uint128_get_nth0(s)                   mol_slice_by_offset(s, 0, 1)
#define         MolReader_Uint128_get_nth1(s)                   mol_slice_by_offset(s, 1, 1)
#define         MolReader_Uint128_get_nth2(s)                   mol_slice_by_offset(s, 2, 1)
#define         MolReader_Uint128_get_nth3(s)                   mol_slice_by_offset(s, 3, 1)
#define         MolReader_Uint128_get_nth4(s)                   mol_slice_by_offset(s, 4, 1)
#define         MolReader_Uint128_get_nth5(s)                   mol_slice_by_offset(s, 5, 1)
#define         MolReader_Uint128_get_nth6(s)                   mol_slice_by_offset(s, 6, 1)
#define         MolReader_Uint128_get_nth7(s)                   mol_slice_by_offset(s, 7, 1)
#define         MolReader_Uint128_get_nth8(s)                   mol_slice_by_offset(s, 8, 1)
#define         MolReader_Uint128_get_nth9(s)                   mol_slice_by_offset(s, 9, 1)
#define         MolReader_Uint128_get_nth10(s)                  mol_slice_by_offset(s, 10, 1)
#define         MolReader_Uint128_get_nth11(s)                  mol_slice_by_offset(s, 11, 1)
#define         MolReader_Uint128_get_nth12(s)                  mol_slice_by_offset(s, 12, 1)
#define         MolReader_Uint128_get_nth13(s)                  mol_slice_by_offset(s, 13, 1)
#define         MolReader_Uint128_get_nth14(s)                  mol_slice_by_offset(s, 14, 1)
#define         MolReader_Uint128_get_nth15(s)                  mol_slice_by_offset(s, 15, 1)
#define         MolReader_Byte32_verify(s, c)                   mol_verify_fixed_size(s, 32)
#define         MolReader_Byte32_get_nth0(s)                    mol_slice_by_offset(s, 0, 1)
#define         MolReader_Byte32_get_nth1(s)                    mol_slice_by_offset(s, 1, 1)
#define         MolReader_Byte32_get_nth2(s)                    mol_slice_by_offset(s, 2, 1)
#define         MolReader_Byte32_get_nth3(s)                    mol_slice_by_offset(s, 3, 1)
#define         MolReader_Byte32_get_nth4(s)                    mol_slice_by_offset(s, 4, 1)
#define         MolReader_Byte32_get_nth5(s)                    mol_slice_by_offset(s, 5, 1)
#define         MolReader_Byte32_get_nth6(s)                    mol_slice_by_offset(s, 6, 1)
#define         MolReader_Byte32_get_nth7(s)                    mol_slice_by_offset(s, 7, 1)
#define         MolReader_Byte32_get_nth8(s)                    mol_slice_by_offset(s, 8, 1)
#define         MolReader_Byte32_get_nth9(s)                    mol_slice_by_offset(s, 9, 1)
#define         MolReader_Byte32_get_nth10(s)                   mol_slice_by_offset(s, 10, 1)
#define         MolReader_Byte32_get_nth11(s)                   mol_slice_by_offset(s, 11, 1)
#define         MolReader_Byte32_get_nth12(s)                   mol_slice_by_offset(s, 12, 1)
#define         MolReader_Byte32_get_nth13(s)                   mol_slice_by_offset(s, 13, 1)
#define         MolReader_Byte32_get_nth14(s)                   mol_slice_by_offset(s, 14, 1)
#define         MolReader_Byte32_get_nth15(s)                   mol_slice_by_offset(s, 15, 1)
#define         MolReader_Byte32_get_nth16(s)                   mol_slice_by_offset(s, 16, 1)
#define         MolReader_Byte32_get_nth17(s)                   mol_slice_by_offset(s, 17, 1)
#define         MolReader_Byte32_get_nth18(s)                   mol_slice_by_offset(s, 18, 1)
#define         MolReader_Byte32_get_nth19(s)                   mol_slice_by_offset(s, 19, 1)
#define         MolReader_Byte32_get_nth20(s)                   mol_slice_by_offset(s, 20, 1)
#define         MolReader_Byte32_get_nth21(s)                   mol_slice_by_offset(s, 21, 1)
#define         MolReader_Byte32_get_nth22(s)                   mol_slice_by_offset(s, 22, 1)
#define         MolReader_Byte32_get_nth23(s)                   mol_slice_by_offset(s, 23, 1)
#define         MolReader_Byte32_get_nth24(s)                   mol_slice_by_offset(s, 24, 1)
#define         MolReader_Byte32_get_nth25(s)                   mol_slice_by_offset(s, 25, 1)
#define         MolReader_Byte32_get_nth26(s)                   mol_slice_by_offset(s, 26, 1)
#define         MolReader_Byte32_get_nth27(s)                   mol_slice_by_offset(s, 27, 1)
#define         MolReader_Byte32_get_nth28(s)                   mol_slice_by_offset(s, 28, 1)
#define         MolReader_Byte32_get_nth29(s)                   mol_slice_by_offset(s, 29, 1)
#define         MolReader_Byte32_get_nth30(s)                   mol_slice_by_offset(s, 30, 1)
#define         MolReader_Byte32_get_nth31(s)                   mol_slice_by_offset(s, 31, 1)
#define         MolReader_Uint256_verify(s, c)                  mol_verify_fixed_size(s, 32)
#define         MolReader_Uint256_get_nth0(s)                   mol_slice_by_offset(s, 0, 1)
#define         MolReader_Uint256_get_nth1(s)                   mol_slice_by_offset(s, 1, 1)
#define         MolReader_Uint256_get_nth2(s)                   mol_slice_by_offset(s, 2, 1)
#define         MolReader_Uint256_get_nth3(s)                   mol_slice_by_offset(s, 3, 1)
#define         MolReader_Uint256_get_nth4(s)                   mol_slice_by_offset(s, 4, 1)
#define         MolReader_Uint256_get_nth5(s)                   mol_slice_by_offset(s, 5, 1)
#define         MolReader_Uint256_get_nth6(s)                   mol_slice_by_offset(s, 6, 1)
#define         MolReader_Uint256_get_nth7(s)                   mol_slice_by_offset(s, 7, 1)
#define         MolReader_Uint256_get_nth8(s)                   mol_slice_by_offset(s, 8, 1)
#define         MolReader_Uint256_get_nth9(s)                   mol_slice_by_offset(s, 9, 1)
#define         MolReader_Uint256_get_nth10(s)                  mol_slice_by_offset(s, 10, 1)
#define         MolReader_Uint256_get_nth11(s)                  mol_slice_by_offset(s, 11, 1)
#define         MolReader_Uint256_get_nth12(s)                  mol_slice_by_offset(s, 12, 1)
#define         MolReader_Uint256_get_nth13(s)                  mol_slice_by_offset(s, 13, 1)
#define         MolReader_Uint256_get_nth14(s)                  mol_slice_by_offset(s, 14, 1)
#define         MolReader_Uint256_get_nth15(s)                  mol_slice_by_offset(s, 15, 1)
#define         MolReader_Uint256_get_nth16(s)                  mol_slice_by_offset(s, 16, 1)
#define         MolReader_Uint256_get_nth17(s)                  mol_slice_by_offset(s, 17, 1)
#define         MolReader_Uint256_get_nth18(s)                  mol_slice_by_offset(s, 18, 1)
#define         MolReader_Uint256_get_nth19(s)                  mol_slice_by_offset(s, 19, 1)
#define         MolReader_Uint256_get_nth20(s)                  mol_slice_by_offset(s, 20, 1)
#define         MolReader_Uint256_get_nth21(s)                  mol_slice_by_offset(s, 21, 1)
#define         MolReader_Uint256_get_nth22(s)                  mol_slice_by_offset(s, 22, 1)
#define         MolReader_Uint256_get_nth23(s)                  mol_slice_by_offset(s, 23, 1)
#define         MolReader_Uint256_get_nth24(s)                  mol_slice_by_offset(s, 24, 1)
#define         MolReader_Uint256_get_nth25(s)                  mol_slice_by_offset(s, 25, 1)
#define         MolReader_Uint256_get_nth26(s)                  mol_slice_by_offset(s, 26, 1)
#define         MolReader_Uint256_get_nth27(s)                  mol_slice_by_offset(s, 27, 1)
#define         MolReader_Uint256_get_nth28(s)                  mol_slice_by_offset(s, 28, 1)
#define         MolReader_Uint256_get_nth29(s)                  mol_slice_by_offset(s, 29, 1)
#define         MolReader_Uint256_get_nth30(s)                  mol_slice_by_offset(s, 30, 1)
#define         MolReader_Uint256_get_nth31(s)                  mol_slice_by_offset(s, 31, 1)
#define         MolReader_Bytes_verify(s, c)                    mol_fixvec_verify(s, 1)
#define         MolReader_Bytes_length(s)                       mol_fixvec_length(s)
#define         MolReader_Bytes_get(s, i)                       mol_fixvec_slice_by_index(s, 1, i)
#define         MolReader_Bytes_raw_bytes(s)                    mol_fixvec_slice_raw_bytes(s)
mol_errno       MolReader_BytesOpt_verify                       (const mol_seg_t*, bool);
#define         MolReader_BytesOpt_is_none(s)                   mol_option_is_none(s)
mol_errno       MolReader_BytesVec_verify                       (const mol_seg_t*, bool);
#define         MolReader_BytesVec_length(s)                    mol_dynvec_length(s)
#define         MolReader_BytesVec_get(s, i)                    mol_dynvec_slice_by_index(s, i)
#define         MolReader_Byte32Vec_verify(s, c)                mol_fixvec_verify(s, 32)
#define         MolReader_Byte32Vec_length(s)                   mol_fixvec_length(s)
#define         MolReader_Byte32Vec_get(s, i)                   mol_fixvec_slice_by_index(s, 32, i)
mol_errno       MolReader_ScriptOpt_verify                      (const mol_seg_t*, bool);
#define         MolReader_ScriptOpt_is_none(s)                  mol_option_is_none(s)
#define         MolReader_ProposalShortId_verify(s, c)          mol_verify_fixed_size(s, 10)
#define         MolReader_ProposalShortId_get_nth0(s)           mol_slice_by_offset(s, 0, 1)
#define         MolReader_ProposalShortId_get_nth1(s)           mol_slice_by_offset(s, 1, 1)
#define         MolReader_ProposalShortId_get_nth2(s)           mol_slice_by_offset(s, 2, 1)
#define         MolReader_ProposalShortId_get_nth3(s)           mol_slice_by_offset(s, 3, 1)
#define         MolReader_ProposalShortId_get_nth4(s)           mol_slice_by_offset(s, 4, 1)
#define         MolReader_ProposalShortId_get_nth5(s)           mol_slice_by_offset(s, 5, 1)
#define         MolReader_ProposalShortId_get_nth6(s)           mol_slice_by_offset(s, 6, 1)
#define         MolReader_ProposalShortId_get_nth7(s)           mol_slice_by_offset(s, 7, 1)
#define         MolReader_ProposalShortId_get_nth8(s)           mol_slice_by_offset(s, 8, 1)
#define         MolReader_ProposalShortId_get_nth9(s)           mol_slice_by_offset(s, 9, 1)
mol_errno       MolReader_UncleBlockVec_verify                  (const mol_seg_t*, bool);
#define         MolReader_UncleBlockVec_length(s)               mol_dynvec_length(s)
#define         MolReader_UncleBlockVec_get(s, i)               mol_dynvec_slice_by_index(s, i)
mol_errno       MolReader_TransactionVec_verify                 (const mol_seg_t*, bool);
#define         MolReader_TransactionVec_length(s)              mol_dynvec_length(s)
#define         MolReader_TransactionVec_get(s, i)              mol_dynvec_slice_by_index(s, i)
#define         MolReader_ProposalShortIdVec_verify(s, c)       mol_fixvec_verify(s, 10)
#define         MolReader_ProposalShortIdVec_length(s)          mol_fixvec_length(s)
#define         MolReader_ProposalShortIdVec_get(s, i)          mol_fixvec_slice_by_index(s, 10, i)
#define         MolReader_CellDepVec_verify(s, c)               mol_fixvec_verify(s, 37)
#define         MolReader_CellDepVec_length(s)                  mol_fixvec_length(s)
#define         MolReader_CellDepVec_get(s, i)                  mol_fixvec_slice_by_index(s, 37, i)
#define         MolReader_CellInputVec_verify(s, c)             mol_fixvec_verify(s, 44)
#define         MolReader_CellInputVec_length(s)                mol_fixvec_length(s)
#define         MolReader_CellInputVec_get(s, i)                mol_fixvec_slice_by_index(s, 44, i)
mol_errno       MolReader_CellOutputVec_verify                  (const mol_seg_t*, bool);
#define         MolReader_CellOutputVec_length(s)               mol_dynvec_length(s)
#define         MolReader_CellOutputVec_get(s, i)               mol_dynvec_slice_by_index(s, i)
mol_errno       MolReader_Script_verify                         (const mol_seg_t*, bool);
#define         MolReader_Script_actual_field_count(s)          mol_table_actual_field_count(s)
#define         MolReader_Script_has_extra_fields(s)            mol_table_has_extra_fields(s, 3)
#define         MolReader_Script_get_code_hash(s)               mol_table_slice_by_index(s, 0)
#define         MolReader_Script_get_hash_type(s)               mol_table_slice_by_index(s, 1)
#define         MolReader_Script_get_args(s)                    mol_table_slice_by_index(s, 2)
#define         MolReader_OutPoint_verify(s, c)                 mol_verify_fixed_size(s, 36)
#define         MolReader_OutPoint_get_tx_hash(s)               mol_slice_by_offset(s, 0, 32)
#define         MolReader_OutPoint_get_index(s)                 mol_slice_by_offset(s, 32, 4)
#define         MolReader_CellInput_verify(s, c)                mol_verify_fixed_size(s, 44)
#define         MolReader_CellInput_get_since(s)                mol_slice_by_offset(s, 0, 8)
#define         MolReader_CellInput_get_previous_output(s)      mol_slice_by_offset(s, 8, 36)
mol_errno       MolReader_CellOutput_verify                     (const mol_seg_t*, bool);
#define         MolReader_CellOutput_actual_field_count(s)      mol_table_actual_field_count(s)
#define         MolReader_CellOutput_has_extra_fields(s)        mol_table_has_extra_fields(s, 3)
#define         MolReader_CellOutput_get_capacity(s)            mol_table_slice_by_index(s, 0)
#define         MolReader_CellOutput_get_lock(s)                mol_table_slice_by_index(s, 1)
#define         MolReader_CellOutput_get_type_(s)               mol_table_slice_by_index(s, 2)
#define         MolReader_CellDep_verify(s, c)                  mol_verify_fixed_size(s, 37)
#define         MolReader_CellDep_get_out_point(s)              mol_slice_by_offset(s, 0, 36)
#define         MolReader_CellDep_get_dep_type(s)               mol_slice_by_offset(s, 36, 1)
mol_errno       MolReader_RawTransaction_verify                 (const mol_seg_t*, bool);
#define         MolReader_RawTransaction_actual_field_count(s)  mol_table_actual_field_count(s)
#define         MolReader_RawTransaction_has_extra_fields(s)    mol_table_has_extra_fields(s, 6)
#define         MolReader_RawTransaction_get_version(s)         mol_table_slice_by_index(s, 0)
#define         MolReader_RawTransaction_get_cell_deps(s)       mol_table_slice_by_index(s, 1)
#define         MolReader_RawTransaction_get_header_deps(s)     mol_table_slice_by_index(s, 2)
#define         MolReader_RawTransaction_get_inputs(s)          mol_table_slice_by_index(s, 3)
#define         MolReader_RawTransaction_get_outputs(s)         mol_table_slice_by_index(s, 4)
#define         MolReader_RawTransaction_get_outputs_data(s)    mol_table_slice_by_index(s, 5)
mol_errno       MolReader_Transaction_verify                    (const mol_seg_t*, bool);
#define         MolReader_Transaction_actual_field_count(s)     mol_table_actual_field_count(s)
#define         MolReader_Transaction_has_extra_fields(s)       mol_table_has_extra_fields(s, 2)
#define         MolReader_Transaction_get_raw(s)                mol_table_slice_by_index(s, 0)
#define         MolReader_Transaction_get_witnesses(s)          mol_table_slice_by_index(s, 1)
#define         MolReader_RawHeader_verify(s, c)                mol_verify_fixed_size(s, 192)
#define         MolReader_RawHeader_get_version(s)              mol_slice_by_offset(s, 0, 4)
#define         MolReader_RawHeader_get_compact_target(s)       mol_slice_by_offset(s, 4, 4)
#define         MolReader_RawHeader_get_timestamp(s)            mol_slice_by_offset(s, 8, 8)
#define         MolReader_RawHeader_get_number(s)               mol_slice_by_offset(s, 16, 8)
#define         MolReader_RawHeader_get_epoch(s)                mol_slice_by_offset(s, 24, 8)
#define         MolReader_RawHeader_get_parent_hash(s)          mol_slice_by_offset(s, 32, 32)
#define         MolReader_RawHeader_get_transactions_root(s)    mol_slice_by_offset(s, 64, 32)
#define         MolReader_RawHeader_get_proposals_hash(s)       mol_slice_by_offset(s, 96, 32)
#define         MolReader_RawHeader_get_uncles_hash(s)          mol_slice_by_offset(s, 128, 32)
#define         MolReader_RawHeader_get_dao(s)                  mol_slice_by_offset(s, 160, 32)
#define         MolReader_Header_verify(s, c)                   mol_verify_fixed_size(s, 208)
#define         MolReader_Header_get_raw(s)                     mol_slice_by_offset(s, 0, 192)
#define         MolReader_Header_get_nonce(s)                   mol_slice_by_offset(s, 192, 16)
mol_errno       MolReader_UncleBlock_verify                     (const mol_seg_t*, bool);
#define         MolReader_UncleBlock_actual_field_count(s)      mol_table_actual_field_count(s)
#define         MolReader_UncleBlock_has_extra_fields(s)        mol_table_has_extra_fields(s, 2)
#define         MolReader_UncleBlock_get_header(s)              mol_table_slice_by_index(s, 0)
#define         MolReader_UncleBlock_get_proposals(s)           mol_table_slice_by_index(s, 1)
mol_errno       MolReader_Block_verify                          (const mol_seg_t*, bool);
#define         MolReader_Block_actual_field_count(s)           mol_table_actual_field_count(s)
#define         MolReader_Block_has_extra_fields(s)             mol_table_has_extra_fields(s, 4)
#define         MolReader_Block_get_header(s)                   mol_table_slice_by_index(s, 0)
#define         MolReader_Block_get_uncles(s)                   mol_table_slice_by_index(s, 1)
#define         MolReader_Block_get_transactions(s)             mol_table_slice_by_index(s, 2)
#define         MolReader_Block_get_proposals(s)                mol_table_slice_by_index(s, 3)
mol_errno       MolReader_CellbaseWitness_verify                (const mol_seg_t*, bool);
#define         MolReader_CellbaseWitness_actual_field_count(s) mol_table_actual_field_count(s)
#define         MolReader_CellbaseWitness_has_extra_fields(s)   mol_table_has_extra_fields(s, 2)
#define         MolReader_CellbaseWitness_get_lock(s)           mol_table_slice_by_index(s, 0)
#define         MolReader_CellbaseWitness_get_message(s)        mol_table_slice_by_index(s, 1)
mol_errno       MolReader_WitnessArgs_verify                    (const mol_seg_t*, bool);
#define         MolReader_WitnessArgs_actual_field_count(s)     mol_table_actual_field_count(s)
#define         MolReader_WitnessArgs_has_extra_fields(s)       mol_table_has_extra_fields(s, 3)
#define         MolReader_WitnessArgs_get_lock(s)               mol_table_slice_by_index(s, 0)
#define         MolReader_WitnessArgs_get_input_type(s)         mol_table_slice_by_index(s, 1)
#define         MolReader_WitnessArgs_get_output_type(s)        mol_table_slice_by_index(s, 2)

/*
 * Builder APIs
 */

#define         MolBuilder_Uint32_init(b)                       mol_builder_initialize_fixed_size(b, 4)
#define         MolBuilder_Uint32_set_nth0(b, p)                mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_Uint32_set_nth1(b, p)                mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_Uint32_set_nth2(b, p)                mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_Uint32_set_nth3(b, p)                mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_Uint32_build(b)                      mol_builder_finalize_simple(b)
#define         MolBuilder_Uint32_clear(b)                      mol_builder_discard(b)
#define         MolBuilder_Uint64_init(b)                       mol_builder_initialize_fixed_size(b, 8)
#define         MolBuilder_Uint64_set_nth0(b, p)                mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_Uint64_set_nth1(b, p)                mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_Uint64_set_nth2(b, p)                mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_Uint64_set_nth3(b, p)                mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_Uint64_set_nth4(b, p)                mol_builder_set_byte_by_offset(b, 4, p)
#define         MolBuilder_Uint64_set_nth5(b, p)                mol_builder_set_byte_by_offset(b, 5, p)
#define         MolBuilder_Uint64_set_nth6(b, p)                mol_builder_set_byte_by_offset(b, 6, p)
#define         MolBuilder_Uint64_set_nth7(b, p)                mol_builder_set_byte_by_offset(b, 7, p)
#define         MolBuilder_Uint64_build(b)                      mol_builder_finalize_simple(b)
#define         MolBuilder_Uint64_clear(b)                      mol_builder_discard(b)
#define         MolBuilder_Uint128_init(b)                      mol_builder_initialize_fixed_size(b, 16)
#define         MolBuilder_Uint128_set_nth0(b, p)               mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_Uint128_set_nth1(b, p)               mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_Uint128_set_nth2(b, p)               mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_Uint128_set_nth3(b, p)               mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_Uint128_set_nth4(b, p)               mol_builder_set_byte_by_offset(b, 4, p)
#define         MolBuilder_Uint128_set_nth5(b, p)               mol_builder_set_byte_by_offset(b, 5, p)
#define         MolBuilder_Uint128_set_nth6(b, p)               mol_builder_set_byte_by_offset(b, 6, p)
#define         MolBuilder_Uint128_set_nth7(b, p)               mol_builder_set_byte_by_offset(b, 7, p)
#define         MolBuilder_Uint128_set_nth8(b, p)               mol_builder_set_byte_by_offset(b, 8, p)
#define         MolBuilder_Uint128_set_nth9(b, p)               mol_builder_set_byte_by_offset(b, 9, p)
#define         MolBuilder_Uint128_set_nth10(b, p)              mol_builder_set_byte_by_offset(b, 10, p)
#define         MolBuilder_Uint128_set_nth11(b, p)              mol_builder_set_byte_by_offset(b, 11, p)
#define         MolBuilder_Uint128_set_nth12(b, p)              mol_builder_set_byte_by_offset(b, 12, p)
#define         MolBuilder_Uint128_set_nth13(b, p)              mol_builder_set_byte_by_offset(b, 13, p)
#define         MolBuilder_Uint128_set_nth14(b, p)              mol_builder_set_byte_by_offset(b, 14, p)
#define         MolBuilder_Uint128_set_nth15(b, p)              mol_builder_set_byte_by_offset(b, 15, p)
#define         MolBuilder_Uint128_build(b)                     mol_builder_finalize_simple(b)
#define         MolBuilder_Uint128_clear(b)                     mol_builder_discard(b)
#define         MolBuilder_Byte32_init(b)                       mol_builder_initialize_fixed_size(b, 32)
#define         MolBuilder_Byte32_set_nth0(b, p)                mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_Byte32_set_nth1(b, p)                mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_Byte32_set_nth2(b, p)                mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_Byte32_set_nth3(b, p)                mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_Byte32_set_nth4(b, p)                mol_builder_set_byte_by_offset(b, 4, p)
#define         MolBuilder_Byte32_set_nth5(b, p)                mol_builder_set_byte_by_offset(b, 5, p)
#define         MolBuilder_Byte32_set_nth6(b, p)                mol_builder_set_byte_by_offset(b, 6, p)
#define         MolBuilder_Byte32_set_nth7(b, p)                mol_builder_set_byte_by_offset(b, 7, p)
#define         MolBuilder_Byte32_set_nth8(b, p)                mol_builder_set_byte_by_offset(b, 8, p)
#define         MolBuilder_Byte32_set_nth9(b, p)                mol_builder_set_byte_by_offset(b, 9, p)
#define         MolBuilder_Byte32_set_nth10(b, p)               mol_builder_set_byte_by_offset(b, 10, p)
#define         MolBuilder_Byte32_set_nth11(b, p)               mol_builder_set_byte_by_offset(b, 11, p)
#define         MolBuilder_Byte32_set_nth12(b, p)               mol_builder_set_byte_by_offset(b, 12, p)
#define         MolBuilder_Byte32_set_nth13(b, p)               mol_builder_set_byte_by_offset(b, 13, p)
#define         MolBuilder_Byte32_set_nth14(b, p)               mol_builder_set_byte_by_offset(b, 14, p)
#define         MolBuilder_Byte32_set_nth15(b, p)               mol_builder_set_byte_by_offset(b, 15, p)
#define         MolBuilder_Byte32_set_nth16(b, p)               mol_builder_set_byte_by_offset(b, 16, p)
#define         MolBuilder_Byte32_set_nth17(b, p)               mol_builder_set_byte_by_offset(b, 17, p)
#define         MolBuilder_Byte32_set_nth18(b, p)               mol_builder_set_byte_by_offset(b, 18, p)
#define         MolBuilder_Byte32_set_nth19(b, p)               mol_builder_set_byte_by_offset(b, 19, p)
#define         MolBuilder_Byte32_set_nth20(b, p)               mol_builder_set_byte_by_offset(b, 20, p)
#define         MolBuilder_Byte32_set_nth21(b, p)               mol_builder_set_byte_by_offset(b, 21, p)
#define         MolBuilder_Byte32_set_nth22(b, p)               mol_builder_set_byte_by_offset(b, 22, p)
#define         MolBuilder_Byte32_set_nth23(b, p)               mol_builder_set_byte_by_offset(b, 23, p)
#define         MolBuilder_Byte32_set_nth24(b, p)               mol_builder_set_byte_by_offset(b, 24, p)
#define         MolBuilder_Byte32_set_nth25(b, p)               mol_builder_set_byte_by_offset(b, 25, p)
#define         MolBuilder_Byte32_set_nth26(b, p)               mol_builder_set_byte_by_offset(b, 26, p)
#define         MolBuilder_Byte32_set_nth27(b, p)               mol_builder_set_byte_by_offset(b, 27, p)
#define         MolBuilder_Byte32_set_nth28(b, p)               mol_builder_set_byte_by_offset(b, 28, p)
#define         MolBuilder_Byte32_set_nth29(b, p)               mol_builder_set_byte_by_offset(b, 29, p)
#define         MolBuilder_Byte32_set_nth30(b, p)               mol_builder_set_byte_by_offset(b, 30, p)
#define         MolBuilder_Byte32_set_nth31(b, p)               mol_builder_set_byte_by_offset(b, 31, p)
#define         MolBuilder_Byte32_build(b)                      mol_builder_finalize_simple(b)
#define         MolBuilder_Byte32_clear(b)                      mol_builder_discard(b)
#define         MolBuilder_Uint256_init(b)                      mol_builder_initialize_fixed_size(b, 32)
#define         MolBuilder_Uint256_set_nth0(b, p)               mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_Uint256_set_nth1(b, p)               mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_Uint256_set_nth2(b, p)               mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_Uint256_set_nth3(b, p)               mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_Uint256_set_nth4(b, p)               mol_builder_set_byte_by_offset(b, 4, p)
#define         MolBuilder_Uint256_set_nth5(b, p)               mol_builder_set_byte_by_offset(b, 5, p)
#define         MolBuilder_Uint256_set_nth6(b, p)               mol_builder_set_byte_by_offset(b, 6, p)
#define         MolBuilder_Uint256_set_nth7(b, p)               mol_builder_set_byte_by_offset(b, 7, p)
#define         MolBuilder_Uint256_set_nth8(b, p)               mol_builder_set_byte_by_offset(b, 8, p)
#define         MolBuilder_Uint256_set_nth9(b, p)               mol_builder_set_byte_by_offset(b, 9, p)
#define         MolBuilder_Uint256_set_nth10(b, p)              mol_builder_set_byte_by_offset(b, 10, p)
#define         MolBuilder_Uint256_set_nth11(b, p)              mol_builder_set_byte_by_offset(b, 11, p)
#define         MolBuilder_Uint256_set_nth12(b, p)              mol_builder_set_byte_by_offset(b, 12, p)
#define         MolBuilder_Uint256_set_nth13(b, p)              mol_builder_set_byte_by_offset(b, 13, p)
#define         MolBuilder_Uint256_set_nth14(b, p)              mol_builder_set_byte_by_offset(b, 14, p)
#define         MolBuilder_Uint256_set_nth15(b, p)              mol_builder_set_byte_by_offset(b, 15, p)
#define         MolBuilder_Uint256_set_nth16(b, p)              mol_builder_set_byte_by_offset(b, 16, p)
#define         MolBuilder_Uint256_set_nth17(b, p)              mol_builder_set_byte_by_offset(b, 17, p)
#define         MolBuilder_Uint256_set_nth18(b, p)              mol_builder_set_byte_by_offset(b, 18, p)
#define         MolBuilder_Uint256_set_nth19(b, p)              mol_builder_set_byte_by_offset(b, 19, p)
#define         MolBuilder_Uint256_set_nth20(b, p)              mol_builder_set_byte_by_offset(b, 20, p)
#define         MolBuilder_Uint256_set_nth21(b, p)              mol_builder_set_byte_by_offset(b, 21, p)
#define         MolBuilder_Uint256_set_nth22(b, p)              mol_builder_set_byte_by_offset(b, 22, p)
#define         MolBuilder_Uint256_set_nth23(b, p)              mol_builder_set_byte_by_offset(b, 23, p)
#define         MolBuilder_Uint256_set_nth24(b, p)              mol_builder_set_byte_by_offset(b, 24, p)
#define         MolBuilder_Uint256_set_nth25(b, p)              mol_builder_set_byte_by_offset(b, 25, p)
#define         MolBuilder_Uint256_set_nth26(b, p)              mol_builder_set_byte_by_offset(b, 26, p)
#define         MolBuilder_Uint256_set_nth27(b, p)              mol_builder_set_byte_by_offset(b, 27, p)
#define         MolBuilder_Uint256_set_nth28(b, p)              mol_builder_set_byte_by_offset(b, 28, p)
#define         MolBuilder_Uint256_set_nth29(b, p)              mol_builder_set_byte_by_offset(b, 29, p)
#define         MolBuilder_Uint256_set_nth30(b, p)              mol_builder_set_byte_by_offset(b, 30, p)
#define         MolBuilder_Uint256_set_nth31(b, p)              mol_builder_set_byte_by_offset(b, 31, p)
#define         MolBuilder_Uint256_build(b)                     mol_builder_finalize_simple(b)
#define         MolBuilder_Uint256_clear(b)                     mol_builder_discard(b)
#define         MolBuilder_Bytes_init(b)                        mol_fixvec_builder_initialize(b, 16)
#define         MolBuilder_Bytes_push(b, p)                     mol_fixvec_builder_push_byte(b, p)
#define         MolBuilder_Bytes_build(b)                       mol_fixvec_builder_finalize(b)
#define         MolBuilder_Bytes_clear(b)                       mol_builder_discard(b)
#define         MolBuilder_BytesOpt_init(b)                     mol_builder_initialize_fixed_size(b, 0)
#define         MolBuilder_BytesOpt_set(b, p, l)                mol_option_builder_set(b, p, l)
#define         MolBuilder_BytesOpt_build(b)                    mol_builder_finalize_simple(b)
#define         MolBuilder_BytesOpt_clear(b)                    mol_builder_discard(b)
#define         MolBuilder_BytesVec_init(b)                     mol_builder_initialize_with_capacity(b, 64, 64)
#define         MolBuilder_BytesVec_push(b, p, l)               mol_dynvec_builder_push(b, p, l)
#define         MolBuilder_BytesVec_build(b)                    mol_dynvec_builder_finalize(b)
#define         MolBuilder_BytesVec_clear(b)                    mol_builder_discard(b)
#define         MolBuilder_Byte32Vec_init(b)                    mol_fixvec_builder_initialize(b, 512)
#define         MolBuilder_Byte32Vec_push(b, p)                 mol_fixvec_builder_push(b, p, 32)
#define         MolBuilder_Byte32Vec_build(b)                   mol_fixvec_builder_finalize(b)
#define         MolBuilder_Byte32Vec_clear(b)                   mol_builder_discard(b)
#define         MolBuilder_ScriptOpt_init(b)                    mol_builder_initialize_fixed_size(b, 0)
#define         MolBuilder_ScriptOpt_set(b, p, l)               mol_option_builder_set(b, p, l)
#define         MolBuilder_ScriptOpt_build(b)                   mol_builder_finalize_simple(b)
#define         MolBuilder_ScriptOpt_clear(b)                   mol_builder_discard(b)
#define         MolBuilder_ProposalShortId_init(b)              mol_builder_initialize_fixed_size(b, 10)
#define         MolBuilder_ProposalShortId_set_nth0(b, p)       mol_builder_set_byte_by_offset(b, 0, p)
#define         MolBuilder_ProposalShortId_set_nth1(b, p)       mol_builder_set_byte_by_offset(b, 1, p)
#define         MolBuilder_ProposalShortId_set_nth2(b, p)       mol_builder_set_byte_by_offset(b, 2, p)
#define         MolBuilder_ProposalShortId_set_nth3(b, p)       mol_builder_set_byte_by_offset(b, 3, p)
#define         MolBuilder_ProposalShortId_set_nth4(b, p)       mol_builder_set_byte_by_offset(b, 4, p)
#define         MolBuilder_ProposalShortId_set_nth5(b, p)       mol_builder_set_byte_by_offset(b, 5, p)
#define         MolBuilder_ProposalShortId_set_nth6(b, p)       mol_builder_set_byte_by_offset(b, 6, p)
#define         MolBuilder_ProposalShortId_set_nth7(b, p)       mol_builder_set_byte_by_offset(b, 7, p)
#define         MolBuilder_ProposalShortId_set_nth8(b, p)       mol_builder_set_byte_by_offset(b, 8, p)
#define         MolBuilder_ProposalShortId_set_nth9(b, p)       mol_builder_set_byte_by_offset(b, 9, p)
#define         MolBuilder_ProposalShortId_build(b)             mol_builder_finalize_simple(b)
#define         MolBuilder_ProposalShortId_clear(b)             mol_builder_discard(b)
#define         MolBuilder_UncleBlockVec_init(b)                mol_builder_initialize_with_capacity(b, 4096, 64)
#define         MolBuilder_UncleBlockVec_push(b, p, l)          mol_dynvec_builder_push(b, p, l)
#define         MolBuilder_UncleBlockVec_build(b)               mol_dynvec_builder_finalize(b)
#define         MolBuilder_UncleBlockVec_clear(b)               mol_builder_discard(b)
#define         MolBuilder_TransactionVec_init(b)               mol_builder_initialize_with_capacity(b, 2048, 64)
#define         MolBuilder_TransactionVec_push(b, p, l)         mol_dynvec_builder_push(b, p, l)
#define         MolBuilder_TransactionVec_build(b)              mol_dynvec_builder_finalize(b)
#define         MolBuilder_TransactionVec_clear(b)              mol_builder_discard(b)
#define         MolBuilder_ProposalShortIdVec_init(b)           mol_fixvec_builder_initialize(b, 256)
#define         MolBuilder_ProposalShortIdVec_push(b, p)        mol_fixvec_builder_push(b, p, 10)
#define         MolBuilder_ProposalShortIdVec_build(b)          mol_fixvec_builder_finalize(b)
#define         MolBuilder_ProposalShortIdVec_clear(b)          mol_builder_discard(b)
#define         MolBuilder_CellDepVec_init(b)                   mol_fixvec_builder_initialize(b, 1024)
#define         MolBuilder_CellDepVec_push(b, p)                mol_fixvec_builder_push(b, p, 37)
#define         MolBuilder_CellDepVec_build(b)                  mol_fixvec_builder_finalize(b)
#define         MolBuilder_CellDepVec_clear(b)                  mol_builder_discard(b)
#define         MolBuilder_CellInputVec_init(b)                 mol_fixvec_builder_initialize(b, 1024)
#define         MolBuilder_CellInputVec_push(b, p)              mol_fixvec_builder_push(b, p, 44)
#define         MolBuilder_CellInputVec_build(b)                mol_fixvec_builder_finalize(b)
#define         MolBuilder_CellInputVec_clear(b)                mol_builder_discard(b)
#define         MolBuilder_CellOutputVec_init(b)                mol_builder_initialize_with_capacity(b, 2048, 64)
#define         MolBuilder_CellOutputVec_push(b, p, l)          mol_dynvec_builder_push(b, p, l)
#define         MolBuilder_CellOutputVec_build(b)               mol_dynvec_builder_finalize(b)
#define         MolBuilder_CellOutputVec_clear(b)               mol_builder_discard(b)
#define         MolBuilder_Script_init(b)                       mol_table_builder_initialize(b, 256, 3)
#define         MolBuilder_Script_set_code_hash(b, p, l)        mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_Script_set_hash_type(b, p)           mol_table_builder_add_byte(b, 1, p)
#define         MolBuilder_Script_set_args(b, p, l)             mol_table_builder_add(b, 2, p, l)
mol_seg_res_t   MolBuilder_Script_build                         (mol_builder_t);
#define         MolBuilder_Script_clear(b)                      mol_builder_discard(b)
#define         MolBuilder_OutPoint_init(b)                     mol_builder_initialize_fixed_size(b, 36)
#define         MolBuilder_OutPoint_set_tx_hash(b, p)           mol_builder_set_by_offset(b, 0, p, 32)
#define         MolBuilder_OutPoint_set_index(b, p)             mol_builder_set_by_offset(b, 32, p, 4)
#define         MolBuilder_OutPoint_build(b)                    mol_builder_finalize_simple(b)
#define         MolBuilder_OutPoint_clear(b)                    mol_builder_discard(b)
#define         MolBuilder_CellInput_init(b)                    mol_builder_initialize_fixed_size(b, 44)
#define         MolBuilder_CellInput_set_since(b, p)            mol_builder_set_by_offset(b, 0, p, 8)
#define         MolBuilder_CellInput_set_previous_output(b, p)  mol_builder_set_by_offset(b, 8, p, 36)
#define         MolBuilder_CellInput_build(b)                   mol_builder_finalize_simple(b)
#define         MolBuilder_CellInput_clear(b)                   mol_builder_discard(b)
#define         MolBuilder_CellOutput_init(b)                   mol_table_builder_initialize(b, 512, 3)
#define         MolBuilder_CellOutput_set_capacity(b, p, l)     mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_CellOutput_set_lock(b, p, l)         mol_table_builder_add(b, 1, p, l)
#define         MolBuilder_CellOutput_set_type_(b, p, l)        mol_table_builder_add(b, 2, p, l)
mol_seg_res_t   MolBuilder_CellOutput_build                     (mol_builder_t);
#define         MolBuilder_CellOutput_clear(b)                  mol_builder_discard(b)
#define         MolBuilder_CellDep_init(b)                      mol_builder_initialize_fixed_size(b, 37)
#define         MolBuilder_CellDep_set_out_point(b, p)          mol_builder_set_by_offset(b, 0, p, 36)
#define         MolBuilder_CellDep_set_dep_type(b, p)           mol_builder_set_byte_by_offset(b, 36, p)
#define         MolBuilder_CellDep_build(b)                     mol_builder_finalize_simple(b)
#define         MolBuilder_CellDep_clear(b)                     mol_builder_discard(b)
#define         MolBuilder_RawTransaction_init(b)               mol_table_builder_initialize(b, 256, 6)
#define         MolBuilder_RawTransaction_set_version(b, p, l)  mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_RawTransaction_set_cell_deps(b, p, l) mol_table_builder_add(b, 1, p, l)
#define         MolBuilder_RawTransaction_set_header_deps(b, p, l) mol_table_builder_add(b, 2, p, l)
#define         MolBuilder_RawTransaction_set_inputs(b, p, l)   mol_table_builder_add(b, 3, p, l)
#define         MolBuilder_RawTransaction_set_outputs(b, p, l)  mol_table_builder_add(b, 4, p, l)
#define         MolBuilder_RawTransaction_set_outputs_data(b, p, l) mol_table_builder_add(b, 5, p, l)
mol_seg_res_t   MolBuilder_RawTransaction_build                 (mol_builder_t);
#define         MolBuilder_RawTransaction_clear(b)              mol_builder_discard(b)
#define         MolBuilder_Transaction_init(b)                  mol_table_builder_initialize(b, 512, 2)
#define         MolBuilder_Transaction_set_raw(b, p, l)         mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_Transaction_set_witnesses(b, p, l)   mol_table_builder_add(b, 1, p, l)
mol_seg_res_t   MolBuilder_Transaction_build                    (mol_builder_t);
#define         MolBuilder_Transaction_clear(b)                 mol_builder_discard(b)
#define         MolBuilder_RawHeader_init(b)                    mol_builder_initialize_fixed_size(b, 192)
#define         MolBuilder_RawHeader_set_version(b, p)          mol_builder_set_by_offset(b, 0, p, 4)
#define         MolBuilder_RawHeader_set_compact_target(b, p)   mol_builder_set_by_offset(b, 4, p, 4)
#define         MolBuilder_RawHeader_set_timestamp(b, p)        mol_builder_set_by_offset(b, 8, p, 8)
#define         MolBuilder_RawHeader_set_number(b, p)           mol_builder_set_by_offset(b, 16, p, 8)
#define         MolBuilder_RawHeader_set_epoch(b, p)            mol_builder_set_by_offset(b, 24, p, 8)
#define         MolBuilder_RawHeader_set_parent_hash(b, p)      mol_builder_set_by_offset(b, 32, p, 32)
#define         MolBuilder_RawHeader_set_transactions_root(b, p) mol_builder_set_by_offset(b, 64, p, 32)
#define         MolBuilder_RawHeader_set_proposals_hash(b, p)   mol_builder_set_by_offset(b, 96, p, 32)
#define         MolBuilder_RawHeader_set_uncles_hash(b, p)      mol_builder_set_by_offset(b, 128, p, 32)
#define         MolBuilder_RawHeader_set_dao(b, p)              mol_builder_set_by_offset(b, 160, p, 32)
#define         MolBuilder_RawHeader_build(b)                   mol_builder_finalize_simple(b)
#define         MolBuilder_RawHeader_clear(b)                   mol_builder_discard(b)
#define         MolBuilder_Header_init(b)                       mol_builder_initialize_fixed_size(b, 208)
#define         MolBuilder_Header_set_raw(b, p)                 mol_builder_set_by_offset(b, 0, p, 192)
#define         MolBuilder_Header_set_nonce(b, p)               mol_builder_set_by_offset(b, 192, p, 16)
#define         MolBuilder_Header_build(b)                      mol_builder_finalize_simple(b)
#define         MolBuilder_Header_clear(b)                      mol_builder_discard(b)
#define         MolBuilder_UncleBlock_init(b)                   mol_table_builder_initialize(b, 1024, 2)
#define         MolBuilder_UncleBlock_set_header(b, p, l)       mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_UncleBlock_set_proposals(b, p, l)    mol_table_builder_add(b, 1, p, l)
mol_seg_res_t   MolBuilder_UncleBlock_build                     (mol_builder_t);
#define         MolBuilder_UncleBlock_clear(b)                  mol_builder_discard(b)
#define         MolBuilder_Block_init(b)                        mol_table_builder_initialize(b, 1024, 4)
#define         MolBuilder_Block_set_header(b, p, l)            mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_Block_set_uncles(b, p, l)            mol_table_builder_add(b, 1, p, l)
#define         MolBuilder_Block_set_transactions(b, p, l)      mol_table_builder_add(b, 2, p, l)
#define         MolBuilder_Block_set_proposals(b, p, l)         mol_table_builder_add(b, 3, p, l)
mol_seg_res_t   MolBuilder_Block_build                          (mol_builder_t);
#define         MolBuilder_Block_clear(b)                       mol_builder_discard(b)
#define         MolBuilder_CellbaseWitness_init(b)              mol_table_builder_initialize(b, 512, 2)
#define         MolBuilder_CellbaseWitness_set_lock(b, p, l)    mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_CellbaseWitness_set_message(b, p, l) mol_table_builder_add(b, 1, p, l)
mol_seg_res_t   MolBuilder_CellbaseWitness_build                (mol_builder_t);
#define         MolBuilder_CellbaseWitness_clear(b)             mol_builder_discard(b)
#define         MolBuilder_WitnessArgs_init(b)                  mol_table_builder_initialize(b, 64, 3)
#define         MolBuilder_WitnessArgs_set_lock(b, p, l)        mol_table_builder_add(b, 0, p, l)
#define         MolBuilder_WitnessArgs_set_input_type(b, p, l)  mol_table_builder_add(b, 1, p, l)
#define         MolBuilder_WitnessArgs_set_output_type(b, p, l) mol_table_builder_add(b, 2, p, l)
mol_seg_res_t   MolBuilder_WitnessArgs_build                    (mol_builder_t);
#define         MolBuilder_WitnessArgs_clear(b)                 mol_builder_discard(b)

/*
 * Default Value
 */

#define ____ 0x00

const uint8_t MolDefault_Uint32[4]                               =  {____, ____, ____, ____};
const uint8_t MolDefault_Uint64[8]                               =  {
    ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_Uint128[16]                             =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
const uint8_t MolDefault_Byte32[32]                              =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_Uint256[32]                             =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_Bytes[4]                                =  {____, ____, ____, ____};
const uint8_t MolDefault_BytesOpt[0]                             =  {};
const uint8_t MolDefault_BytesVec[4]                             =  {0x04, ____, ____, ____};
const uint8_t MolDefault_Byte32Vec[4]                            =  {____, ____, ____, ____};
const uint8_t MolDefault_ScriptOpt[0]                            =  {};
const uint8_t MolDefault_ProposalShortId[10]                     =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_UncleBlockVec[4]                        =  {0x04, ____, ____, ____};
const uint8_t MolDefault_TransactionVec[4]                       =  {0x04, ____, ____, ____};
const uint8_t MolDefault_ProposalShortIdVec[4]                   =  {____, ____, ____, ____};
const uint8_t MolDefault_CellDepVec[4]                           =  {____, ____, ____, ____};
const uint8_t MolDefault_CellInputVec[4]                         =  {____, ____, ____, ____};
const uint8_t MolDefault_CellOutputVec[4]                        =  {0x04, ____, ____, ____};
const uint8_t MolDefault_Script[53]                              =  {
    0x35, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x31, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_OutPoint[36]                            =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_CellInput[44]                           =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_CellOutput[77]                          =  {
    0x4d, ____, ____, ____, 0x10, ____, ____, ____, 0x18, ____, ____, ____,
    0x4d, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x35, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x31, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_CellDep[37]                             =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____,
};
const uint8_t MolDefault_RawTransaction[52]                      =  {
    0x34, ____, ____, ____, 0x1c, ____, ____, ____, 0x20, ____, ____, ____,
    0x24, ____, ____, ____, 0x28, ____, ____, ____, 0x2c, ____, ____, ____,
    0x30, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
    0x04, ____, ____, ____,
};
const uint8_t MolDefault_Transaction[68]                         =  {
    0x44, ____, ____, ____, 0x0c, ____, ____, ____, 0x40, ____, ____, ____,
    0x34, ____, ____, ____, 0x1c, ____, ____, ____, 0x20, ____, ____, ____,
    0x24, ____, ____, ____, 0x28, ____, ____, ____, 0x2c, ____, ____, ____,
    0x30, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
    0x04, ____, ____, ____, 0x04, ____, ____, ____,
};
const uint8_t MolDefault_RawHeader[192]                          =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_Header[208]                             =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
const uint8_t MolDefault_UncleBlock[224]                         =  {
    0xe0, ____, ____, ____, 0x0c, ____, ____, ____, 0xdc, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_Block[240]                              =  {
    0xf0, ____, ____, ____, 0x14, ____, ____, ____, 0xe4, ____, ____, ____,
    0xe8, ____, ____, ____, 0xec, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, 0x04, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_CellbaseWitness[69]                     =  {
    0x45, ____, ____, ____, 0x0c, ____, ____, ____, 0x41, ____, ____, ____,
    0x35, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x31, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
const uint8_t MolDefault_WitnessArgs[16]                         =  {
    0x10, ____, ____, ____, 0x10, ____, ____, ____, 0x10, ____, ____, ____,
    0x10, ____, ____, ____,
};

#undef ____

/*
 * Reader Functions
 */

mol_errno MolReader_BytesOpt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Bytes_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
mol_errno MolReader_BytesVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Bytes_verify(&inner, compatible);
}
mol_errno MolReader_ScriptOpt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Script_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
mol_errno MolReader_UncleBlockVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_UncleBlock_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_UncleBlock_verify(&inner, compatible);
}
mol_errno MolReader_TransactionVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Transaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Transaction_verify(&inner, compatible);
}
mol_errno MolReader_CellOutputVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_CellOutput_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_CellOutput_verify(&inner, compatible);
}
mol_errno MolReader_Script_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        if (offsets[2] - offsets[1] != 1) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_CellOutput_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Script_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_ScriptOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_RawTransaction_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 6) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 6) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_CellDepVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_CellInputVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_CellOutputVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[5];
        inner.size = offsets[6] - offsets[5];
        errno = MolReader_BytesVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_Transaction_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_RawTransaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_BytesVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_UncleBlock_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Header_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_Block_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 4) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 4) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Header_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_UncleBlockVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_TransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_CellbaseWitness_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Script_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
mol_errno MolReader_WitnessArgs_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_BytesOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_BytesOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_BytesOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}

/*
 * Builder Functions
 */

mol_seg_res_t MolBuilder_Script_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 1 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 1 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 1;
        *dst = 0;
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_CellOutput_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 53 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 0 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 53 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 0 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 53;
        memcpy(dst, &MolDefault_Script, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_ScriptOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_RawTransaction_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 28;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[11];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[11];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_CellDepVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_CellInputVec, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_CellOutputVec, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[11];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_BytesVec, len);
    } else {
        mol_num_t of = builder.number_ptr[10];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_Transaction_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 52 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 52 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 52;
        memcpy(dst, &MolDefault_RawTransaction, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_BytesVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_UncleBlock_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 208 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 208 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 208;
        memcpy(dst, &MolDefault_Header, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_Block_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 20;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 208 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 208 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 208;
        memcpy(dst, &MolDefault_Header, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_UncleBlockVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_TransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_CellbaseWitness_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 53 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 53 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 53;
        memcpy(dst, &MolDefault_Script, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
mol_seg_res_t MolBuilder_WitnessArgs_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 0 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 0 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 0 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 0 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 0 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 0 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BytesOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BytesOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BytesOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
#ifdef __cplusplus
_CPP_END
#undef _CPP_BEGIN
#undef _CPP_END
#endif /* __cplusplus */

#endif /* BLOCKCHAIN_H */
